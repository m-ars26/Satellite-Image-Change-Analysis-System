import streamlit as st
import sys
import os
import numpy as np
import cv2
from PIL import Image
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px
import pandas as pd
import io
import base64
from datetime import datetime
import json
import matplotlib.pyplot as plt

# Mevcut src klas√∂r√ºn√º Python path'ine ekler
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Sayfa konfig√ºrasyonu yapƒ±yorum
st.set_page_config(
    page_title="Uydu G√∂r√ºnt√º Deƒüi≈üim Analizi - Advanced",
    page_icon="üõ∞Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)


PREPROCESSOR_AVAILABLE = False
UTILS_AVAILABLE = False
VISUALIZER_AVAILABLE = False
TEST_MODULE_AVAILABLE = False

# Preprocessor mod√ºl√ºn√º import ediyorum
try:
    from preprocessor import ImagePreprocessor
    PREPROCESSOR_AVAILABLE = True
    if 'preprocessor_loaded' not in st.session_state:
        st.session_state.preprocessor_loaded = True
        st.success("‚úÖ Geli≈ümi≈ü ImagePreprocessor y√ºklendi!")
except ImportError as e:
    ImagePreprocessor = None
    if 'preprocessor_error' not in st.session_state:
        st.session_state.preprocessor_error = True
        st.warning(f"‚ö†Ô∏è preprocessor.py y√ºklenemedi: {e}")

# Utils mod√ºl√ºn√º import ediyorum
try:
    import utils
    UTILS_AVAILABLE = True
    if hasattr(utils, 'export_results'):
        export_results = utils.export_results
    else:
        export_results = None
except ImportError:
    export_results = None
    if 'utils_info_shown' not in st.session_state:
        st.session_state.utils_info_shown = True
        st.info("‚ÑπÔ∏è utils.py bulunamadƒ± - temel export kullanƒ±lacak")

# Visualizer mod√ºl√ºn√º import ediyorum
try:
    import visualizer
    VISUALIZER_AVAILABLE = True
    if hasattr(visualizer, 'create_advanced_visualization'):
        create_advanced_visualization = visualizer.create_advanced_visualization
    else:
        create_advanced_visualization = None
except ImportError:
    create_advanced_visualization = None
    if 'visualizer_info_shown' not in st.session_state:
        st.session_state.visualizer_info_shown = True
        st.info("‚ÑπÔ∏è visualizer.py bulunamadƒ± - temel g√∂rselle≈ütirme kullanƒ±lacak")

# Custom CSS - Daha sade ve okunabilir bir tema ve Overlay sorununun √ß√∂z√ºm√º
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem;
        color: #2c3e50;
        text-align: center;
        margin-bottom: 2rem;
        font-weight: 600;
        background: linear-gradient(90deg, #3498db, #2980b9);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: none;
    }
    .metric-container {
        background: #ffffff;
        color: #2c3e50;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 0.5rem 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border: 1px solid #e1e8ed;
    }
    .change-detected {
        background: #ffffff;
        color: #e74c3c;
        border: 2px solid #e74c3c;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(231,76,60,0.1);
    }
    .no-change {
        background: #ffffff;
        color: #27ae60;
        border: 2px solid #27ae60;
        border-radius: 10px;
        padding: 1.5rem;
        margin: 1rem 0;
        box-shadow: 0 2px 8px rgba(39,174,96,0.1);
    }
    .status-card {
        background: #f8f9fa;
        color: #2c3e50;
        border-radius: 8px;
        padding: 1rem;
        margin: 0.5rem 0;
        border-left: 4px solid #3498db;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        font-weight: 500;
    }
    .method-badge {
        background: #3498db;
        color: white;
        padding: 0.3rem 0.8rem;
        border-radius: 15px;
        font-size: 0.8rem;
        font-weight: 600;
        display: inline-block;
    }
    .feature-highlight {
        background: #ffffff;
        color: #2c3e50;
        padding: 1.5rem;
        border-radius: 10px;
        margin: 1rem 0;
        border: 1px solid #3498db;
        box-shadow: 0 2px 8px rgba(52,152,219,0.1);
    }
    .feature-highlight h4 {
        color: #3498db;
        margin-bottom: 1rem;
        font-weight: 600;
    }
    .feature-highlight p {
        color: #2c3e50;
        line-height: 1.6;
        margin: 0;
    }
    /* Streamlit √∂zel sƒ±nƒ±flarƒ±nƒ± ge√ßersiz kƒ±l */
    .stMarkdown {
        color: #2c3e50;
    }
    /* Sidebar styling */
    .css-1d391kg {
        background-color: #f8f9fa;
    }
    /* Metric widget styling */
    .metric-value {
        font-size: 1.2rem;
        font-weight: 600;
        color: #2c3e50;
    }
    
    /* OVERLAY SORUNUNUN √á√ñZ√úM√ú */
    /* Plotly chart container  */
    .js-plotly-plot {
        z-index: 1 !important;
        position: relative !important;
    }
    
    /* Streamlit plotly container */
    .stPlotlyChart {
        z-index: 1 !important;
        position: relative !important;
        overflow: visible !important;
    }
    
    /* Plotly modebar */
    .modebar {
        z-index: 10 !important;
        position: relative !important;
    }
    
    /* Container spacing  */
    .plotly-container {
        margin: 2rem 0 !important;
        padding: 1rem !important;
        background: white;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    /* Chart height */
    .stPlotlyChart > div {
        height: 600px !important;
    }
    
    /* Sidebar metric */
    .css-1lcbmhc {
        z-index: 5 !important;
    }
</style>
""", unsafe_allow_html=True)

def ensure_same_size(img1, img2, target_size=None):
    """ƒ∞ki g√∂r√ºnt√ºy√º aynƒ± boyuta getirdim"""
    if target_size is None:
        # ƒ∞ki g√∂r√ºnt√º arasƒ±nda en k√º√ß√ºk ortak boyutu bulma 
        h1, w1 = img1.shape[:2]
        h2, w2 = img2.shape[:2]
        target_h = min(h1, h2)
        target_w = min(w1, w2)
        target_size = (target_w, target_h)
    else:
        target_w, target_h = target_size
    
    # G√∂r√ºnt√ºleri yeniden boyutlandƒ±rma
    img1_resized = cv2.resize(img1, (target_w, target_h), interpolation=cv2.INTER_LANCZOS4)
    img2_resized = cv2.resize(img2, (target_w, target_h), interpolation=cv2.INTER_LANCZOS4)
    
    return img1_resized, img2_resized

def convert_numpy_types(obj):
    """NumPy tiplerini Python tiplerine √ßevirme (JSON i√ßin)"""
    if isinstance(obj, np.integer):
        return int(obj)
    elif isinstance(obj, np.floating):
        return float(obj)
    elif isinstance(obj, np.ndarray):
        return obj.tolist()
    elif isinstance(obj, dict):
        return {key: convert_numpy_types(value) for key, value in obj.items()}
    elif isinstance(obj, list):
        return [convert_numpy_types(item) for item in obj]
    else:
        return obj

class EnhancedChangeDetectionApp:
    def __init__(self):
        self.before_image = None
        self.after_image = None
        self.results = {}
        self.available_methods = self._get_available_methods()
        
        # ImagePreprocessor'ƒ± ba≈ülatƒ±yorum
        if PREPROCESSOR_AVAILABLE and ImagePreprocessor:
            try:
                self.preprocessor = ImagePreprocessor(target_size=(1024, 1024))
                if 'advanced_preprocessing_status' not in st.session_state:
                    st.session_state.advanced_preprocessing_status = True
                    st.info("üöÄ Geli≈ümi≈ü √∂n i≈üleme sistemi aktif!")
            except Exception as e:
                self.preprocessor = None
                st.error(f"ImagePreprocessor ba≈ülatƒ±lamadƒ±: {e}")
        else:
            self.preprocessor = None
            if 'basic_preprocessing_status' not in st.session_state:
                st.session_state.basic_preprocessing_status = True
                st.info("üìù Temel √∂n i≈üleme sistemi kullanƒ±lƒ±yor")
        
    def _get_available_methods(self):
        """Kullanƒ±labilir y√∂ntemleri tespit et"""
        methods = {
            'Statistical': {'available': True, 'description': 'Temel istatistiksel fark analizi'},
            'Morphological': {'available': True, 'description': 'Morfolojik gradyan analizi'},
            'Advanced Preprocessing': {'available': PREPROCESSOR_AVAILABLE, 'description': 'Geli≈ümi≈ü √∂n i≈üleme + analiz'},
            'Hybrid Enhanced': {'available': True, 'description': 'Birle≈üik geli≈ümi≈ü y√∂ntem'}
        }
        return methods
    
    def apply_advanced_preprocessing(self, img1, img2):
        """√ñn i≈üleme uygula"""
        if self.preprocessor is None:
            return img1, img2, {'preprocessing_applied': False, 'error': 'Preprocessor not available'}
        
        try:
            # √ñnce g√∂r√ºnt√ºleri aynƒ± boyuta getiriyorum
            img1, img2 = ensure_same_size(img1, img2, target_size=(1024, 1024))
            
            # G√∂r√ºnt√ºleri BGR formatƒ±na √ßeviriyorum (OpenCV i√ßin)
            if len(img1.shape) == 3 and img1.shape[2] == 3:
                bgr1 = cv2.cvtColor(img1, cv2.COLOR_RGB2BGR)
                bgr2 = cv2.cvtColor(img2, cv2.COLOR_RGB2BGR)
            else:
                bgr1, bgr2 = img1, img2
            
            # √ñn i≈üleme pipeline uyguluyorum
            processed1 = self.preprocessor._preprocess_pipeline(bgr1)
            processed2 = self.preprocessor._preprocess_pipeline(bgr2)
            
            # G√∂r√ºnt√ºleri tekrar aynƒ± boyuta getiriyorum (√∂n i≈üleme sonrasƒ± boyut deƒüi≈üebiliyor)
            processed1, processed2 = ensure_same_size(processed1, processed2)
            
            # G√∂r√ºnt√ºleri hizalƒ±yorum
            aligned1, aligned2 = self.preprocessor.align_images(processed1, processed2)
            
            # Hizalama sonrasƒ± boyutlarƒ± kontrol ediyorum
            if aligned1 is not None and aligned2 is not None:
                aligned1, aligned2 = ensure_same_size(aligned1, aligned2)
            else:
                aligned1, aligned2 = processed1, processed2
            
            # Hizalama kalitesini hesaplƒ±yorum
            alignment_quality = self.preprocessor.calculate_alignment_quality(aligned1, aligned2)
            
            # RGB formatƒ±na geri √ßeviriyorum
            if len(aligned1.shape) == 3:
                rgb1 = cv2.cvtColor(aligned1, cv2.COLOR_BGR2RGB)
                rgb2 = cv2.cvtColor(aligned2, cv2.COLOR_BGR2RGB)
            else:
                rgb1, rgb2 = aligned1, aligned2
            
            # ƒ∞statistikleri hesaplƒ±yorum
            stats1 = self.preprocessor.get_preprocessing_stats(bgr1, aligned1)
            stats2 = self.preprocessor.get_preprocessing_stats(bgr2, aligned2)
            
            return rgb1, rgb2, {
                'alignment_quality': float(alignment_quality),
                'stats1': convert_numpy_types(stats1),
                'stats2': convert_numpy_types(stats2),
                'preprocessing_applied': True,
                'success': True
            }
            
        except Exception as e:
            st.error(f"Geli≈ümi≈ü √∂n i≈üleme hatasƒ±: {e}")
            return img1, img2, {'preprocessing_applied': False, 'error': str(e)}
    
    def detect_changes_statistical(self, img1, img2, threshold=30, use_advanced=True):
        """ƒ∞statistiksel analiz"""
        preprocessing_info = {'preprocessing_applied': False}
        
        try:
            # √ñncelikle g√∂r√ºnt√ºleri aynƒ± boyuta getiriyorum
            img1, img2 = ensure_same_size(img1, img2)
            
            # Preprocessor'i uyguluyorum
            if use_advanced and self.preprocessor is not None:
                try:
                    result = self.apply_advanced_preprocessing(img1, img2)
                    if len(result) == 3:
                        img1, img2, preprocessing_info = result
                    else:
                        img1, img2 = result
                except Exception as e:
                    st.warning(f"Geli≈ümi≈ü √∂n i≈üleme hatasƒ±: {e}, temel y√∂ntem kullanƒ±lƒ±yor")
            
            # Gri tonlama
            gray1 = cv2.cvtColor(img1, cv2.COLOR_RGB2GRAY) if len(img1.shape) == 3 else img1
            gray2 = cv2.cvtColor(img2, cv2.COLOR_RGB2GRAY) if len(img2.shape) == 3 else img2
            
            # Boyut kontrol√º ve e≈üitleme
            gray1, gray2 = ensure_same_size(gray1, gray2)
            h, w = gray1.shape[:2]
            
            # Gaussian blur ile g√ºr√ºlt√º azaltma
            gray1 = cv2.GaussianBlur(gray1, (5, 5), 0)
            gray2 = cv2.GaussianBlur(gray2, (5, 5), 0)
            
            # Fark hesaplama
            diff = cv2.absdiff(gray1, gray2)
            
            # Adaptive threshold
            change_mask = cv2.adaptiveThreshold(diff, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                              cv2.THRESH_BINARY, 11, 2)
            
            # Morfolojik temizleme
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
            change_mask = cv2.morphologyEx(change_mask, cv2.MORPH_OPEN, kernel)
            change_mask = cv2.morphologyEx(change_mask, cv2.MORPH_CLOSE, kernel)
            
            # ƒ∞statistikleri hesaplama
            total_pixels = h * w
            changed_pixels = np.sum(change_mask > 0)
            change_percentage = (changed_pixels / total_pixels) * 100
            
            # Confidence haritasƒ±
            confidence_map = cv2.normalize(diff.astype(np.float32), None, 0, 1, cv2.NORM_MINMAX)
            
            result = {
                'change_mask': change_mask,
                'difference_map': diff,
                'confidence_map': confidence_map,
                'change_percentage': float(change_percentage),
                'changed_pixels': int(changed_pixels),
                'total_pixels': int(total_pixels),
                'method': 'Statistical Enhanced',
                'preprocessing_info': convert_numpy_types(preprocessing_info)
            }
            
            return result
            
        except Exception as e:
            st.error(f"Statistical analiz hatasƒ±: {e}")
            raise
    
    def detect_changes_morphological(self, img1, img2):
        """Morfolojik analiz"""
        try:
            # √ñncelikle g√∂r√ºnt√ºleri aynƒ± boyuta getiriyorum
            img1, img2 = ensure_same_size(img1, img2)
            
            gray1 = cv2.cvtColor(img1, cv2.COLOR_RGB2GRAY) if len(img1.shape) == 3 else img1
            gray2 = cv2.cvtColor(img2, cv2.COLOR_RGB2GRAY) if len(img2.shape) == 3 else img2
            
            # Boyut kontrol√º
            gray1, gray2 = ensure_same_size(gray1, gray2)
            h, w = gray1.shape[:2]
            
            # √áoklu √∂l√ßek morfolojik analiz
            kernels = [
                cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)),
                cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5)),
                cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (7, 7))
            ]
            
            combined_diff = np.zeros_like(gray1, dtype=np.float32)
            
            for kernel in kernels:
                # Morfolojik gradyan
                grad1 = cv2.morphologyEx(gray1, cv2.MORPH_GRADIENT, kernel)
                grad2 = cv2.morphologyEx(gray2, cv2.MORPH_GRADIENT, kernel)
                
                # Fark hesapla
                diff = cv2.absdiff(grad1, grad2)
                combined_diff += diff.astype(np.float32)
            
            # Normalize et
            combined_diff = cv2.normalize(combined_diff, None, 0, 255, cv2.NORM_MINMAX).astype(np.uint8)
            
            # Threshold
            _, change_mask = cv2.threshold(combined_diff, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            
            # Temizleme
            change_mask = cv2.medianBlur(change_mask, 5)
            
            total_pixels = h * w
            changed_pixels = np.sum(change_mask > 0)
            change_percentage = (changed_pixels / total_pixels) * 100
            
            return {
                'change_mask': change_mask,
                'difference_map': combined_diff,
                'confidence_map': combined_diff / 255.0,
                'change_percentage': float(change_percentage),
                'changed_pixels': int(changed_pixels),
                'total_pixels': int(total_pixels),
                'method': 'Morphological Enhanced'
            }
            
        except Exception as e:
            st.error(f"Morphological analiz hatasƒ±: {e}")
            raise
    
    def detect_changes_advanced_preprocessing(self, img1, img2):
        """Preprocessing y√∂ntemi"""
        if not PREPROCESSOR_AVAILABLE:
            st.warning("Advanced Preprocessing i√ßin preprocessor.py gerekli!")
            return self.detect_changes_statistical(img1, img2, use_advanced=False)
        
        try:
            # Preprocessing uyguluyorum
            result = self.apply_advanced_preprocessing(img1, img2)
            if len(result) == 3:
                processed_img1, processed_img2, prep_info = result
            else:
                processed_img1, processed_img2 = result
                prep_info = {'preprocessing_applied': False}
            
            # Statistical analiz uyguluyorum
            analysis_result = self.detect_changes_statistical(processed_img1, processed_img2, use_advanced=False)
            analysis_result['method'] = 'Advanced Preprocessing + Statistical'
            analysis_result['preprocessing_info'] = convert_numpy_types(prep_info)
            
            return analysis_result
            
        except Exception as e:
            st.error(f"Advanced Preprocessing hatasƒ±: {e}")
            raise
    
    def detect_changes_hybrid(self, img1, img2):
        """Hibrit y√∂ntem - Statistical + Morphological"""
        try:
            # √ñncelikle g√∂r√ºnt√ºleri aynƒ± boyuta getiriyorum
            img1, img2 = ensure_same_size(img1, img2)
            
            # Statistical analiz
            stat_results = self.detect_changes_statistical(img1, img2, use_advanced=True)
            
            # Morphological analiz
            morph_results = self.detect_changes_morphological(img1, img2)
            
            # Boyut kontrol√º - change mask'lerin aynƒ± boyutta olduƒüundan emin oluyorum
            stat_mask = stat_results['change_mask']
            morph_mask = morph_results['change_mask']
            
            if stat_mask.shape != morph_mask.shape:
                # Daha k√º√ß√ºk boyuta resize ediyorum
                target_h = min(stat_mask.shape[0], morph_mask.shape[0])
                target_w = min(stat_mask.shape[1], morph_mask.shape[1])
                
                stat_mask = cv2.resize(stat_mask, (target_w, target_h))
                morph_mask = cv2.resize(morph_mask, (target_w, target_h))
            
            # Sonu√ßlarƒ± birle≈ütiriyorum
            combined_mask = cv2.bitwise_or(stat_mask, morph_mask)
            
            # Confidence map'leri de aynƒ± boyuta getiriyorum
            stat_conf = stat_results['confidence_map']
            morph_conf = morph_results['confidence_map']
            
            if stat_conf.shape != morph_conf.shape:
                target_h = min(stat_conf.shape[0], morph_conf.shape[0])
                target_w = min(stat_conf.shape[1], morph_conf.shape[1])
                
                stat_conf = cv2.resize(stat_conf, (target_w, target_h))
                morph_conf = cv2.resize(morph_conf, (target_w, target_h))
            
            # Confidence'larƒ± aƒüƒ±rlƒ±klƒ± ortalama
            combined_confidence = (stat_conf * 0.6 + morph_conf * 0.4)
            
            total_pixels = combined_mask.shape[0] * combined_mask.shape[1]
            changed_pixels = np.sum(combined_mask > 0)
            change_percentage = (changed_pixels / total_pixels) * 100
            
            return {
                'change_mask': combined_mask,
                'difference_map': stat_results['difference_map'],
                'confidence_map': combined_confidence,
                'change_percentage': float(change_percentage),
                'changed_pixels': int(changed_pixels),
                'total_pixels': int(total_pixels),
                'method': 'Hybrid Enhanced (Statistical + Morphological)',
                'individual_results': {
                    'statistical': convert_numpy_types(stat_results),
                    'morphological': convert_numpy_types(morph_results)
                },
                'preprocessing_info': convert_numpy_types(stat_results.get('preprocessing_info', {}))
            }
            
        except Exception as e:
            st.error(f"Hybrid analiz hatasƒ±: {e}")
            raise
    
    def analyze_change_regions(self, change_mask):
        """Deƒüi≈üim b√∂lgelerini analiz etme"""
        try:
            # Baƒülƒ± bile≈üenleri buluyorum
            num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(change_mask, 8, cv2.CV_32S)
            
            regions = []
            for i in range(1, num_labels):  # 0 arka plan
                area = stats[i, cv2.CC_STAT_AREA]
                if area > 50:  # Minimum alan filtresi
                    regions.append({
                        'id': int(i),
                        'area': int(area),
                        'centroid': [float(centroids[i][0]), float(centroids[i][1])],
                        'bbox': [int(stats[i][j]) for j in range(5)]
                    })
            
            # Alan'a g√∂re sƒ±ralama
            regions.sort(key=lambda x: x['area'], reverse=True)
            
            return regions[:10]  # En b√ºy√ºk 10 b√∂lge
            
        except Exception as e:
            st.error(f"B√∂lge analizi hatasƒ±: {e}")
            return []
    
    def create_overlay_visualization(self, before_img, after_img, change_mask):
        """Overlay g√∂rselle≈ütirmesi"""
        try:
            # G√∂r√ºnt√ºleri aynƒ± boyuta getiriyorum
            before_img, after_img = ensure_same_size(before_img, after_img)
            
            # Change mask'i g√∂r√ºnt√º boyutuna getiriyorum
            if change_mask.shape[:2] != after_img.shape[:2]:
                change_mask = cv2.resize(change_mask, (after_img.shape[1], after_img.shape[0]))
            
            # Deƒüi≈üim maskesini renklendiriyorum
            colored_mask = np.zeros_like(after_img)
            colored_mask[change_mask > 0] = [255, 0, 0]  # Kƒ±rmƒ±zƒ±
            
            # Overlay olu≈üturuyorum
            overlay = cv2.addWeighted(after_img, 0.7, colored_mask, 0.3, 0)
            
            return overlay
            
        except Exception as e:
            st.error(f"Overlay olu≈üturma hatasƒ±: {e}")
            return after_img

def main():
    st.markdown('<h1 class="main-header">üõ∞Ô∏è Geli≈ümi≈ü Uydu G√∂r√ºnt√º Deƒüi≈üim Analizi</h1>', unsafe_allow_html=True)
    
    app = EnhancedChangeDetectionApp()
    
    # Sistem durumu kontrol√º
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        status = "üü¢ Aktif" if PREPROCESSOR_AVAILABLE else "üü° Temel"
        st.markdown(f"""
        <div class="status-card">
            <strong>Preprocessor:</strong> {status}
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        status = "üü¢ Aktif" if UTILS_AVAILABLE else "üü° Temel"
        st.markdown(f"""
        <div class="status-card">
            <strong>Utils:</strong> {status}
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        status = "üü¢ Aktif" if VISUALIZER_AVAILABLE else "üü° Temel"
        st.markdown(f"""
        <div class="status-card">
            <strong>Visualizer:</strong> {status}
        </div>
        """, unsafe_allow_html=True)
    
    with col4:
        st.markdown(f"""
        <div class="status-card">
            <strong>Sistem:</strong> üü¢ Hazƒ±r
        </div>
        """, unsafe_allow_html=True)
    
    # √ñzellik vurgusu 
    if PREPROCESSOR_AVAILABLE:
        st.markdown("""
        <div class="feature-highlight">
            <h4>üöÄ √ñzellikler Aktif!</h4>
            <p>
            ‚úÖ Otomatik g√∂r√ºnt√º hizalama<br>
            ‚úÖ G√ºr√ºlt√º azaltma ve kontrast artƒ±rma<br>
            ‚úÖ Kalite metrikleri<br>
            ‚úÖ Boyut uyumsuzluklarƒ± otomatik d√ºzeltilir
            </p>
        </div>
        """, unsafe_allow_html=True)
    else:
        st.markdown("""
        <div class="feature-highlight">
            <h4>üìù Temel Analiz Modu</h4>
            <p>
            ‚úÖ ƒ∞statistiksel deƒüi≈üim analizi<br>
            ‚úÖ Morfolojik analiz<br>
            ‚úÖ Hibrit y√∂ntem<br>
            üí° preprocessor.py y√ºkleyerek geli≈ümi≈ü √∂zellikleri aktifle≈ütirin
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    # Sidebar
    with st.sidebar:
        st.header("üîß Analiz Parametreleri")
        
        # Y√∂ntem se√ßimi
        available_methods = [name for name, info in app.available_methods.items() if info['available']]
        method = st.selectbox(
            "Analiz Y√∂ntemi",
            available_methods,
            help="Kullanƒ±lacak deƒüi≈üim tespit algoritmasƒ±"
        )
        
        # Se√ßilen y√∂ntem bilgisi
        if method in app.available_methods:
            st.info(f"‚ÑπÔ∏è {app.available_methods[method]['description']}")
        
        st.markdown("---")
        
        # Temel parametreler
        sensitivity = st.slider(
            "Duyarlƒ±lƒ±k",
            min_value=1,
            max_value=10,
            value=5,
            help="1: Az hassas, 10: √áok hassas"
        )
        
        min_region_size = st.slider(
            "Min. B√∂lge Boyutu",
            min_value=10,
            max_value=1000,
            value=100,
            help="G√∂z ardƒ± edilecek minimum alan (piksel)"
        )
        
        morphological_ops = st.checkbox(
            "Morfolojik Temizleme",
            value=True,
            help="Opening/Closing operasyonlarƒ±"
        )
        
        # Sonu√ßlarƒ± g√∂sterme
        if 'results' in st.session_state:
            st.markdown("---")
            st.subheader("üìä Anlƒ±k Sonu√ßlar")
            results = st.session_state.results
            change_pct = results.get('change_percentage', 0)
            
            st.metric("Deƒüi≈üim Oranƒ±", f"{change_pct:.2f}%")
            st.metric("Deƒüi≈üen Piksel", f"{results.get('changed_pixels', 0):,}")
            st.metric("Kullanƒ±lan Y√∂ntem", results.get('method', 'N/A'))
    
    # Ana i√ßerik
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üì∏ √ñnceki G√∂r√ºnt√º (Before)")
        before_file = st.file_uploader(
            "√ñnceki g√∂r√ºnt√ºy√º y√ºkleyin",
            type=['png', 'jpg', 'jpeg', 'tiff', 'bmp'],
            key="before",
            help="Kar≈üƒ±la≈ütƒ±rmanƒ±n referans g√∂r√ºnt√ºs√º"
        )
        
        if before_file:
            app.before_image = np.array(Image.open(before_file))
            st.image(app.before_image, caption="√ñnceki G√∂r√ºnt√º", use_container_width=True)
            st.info(f"üìê Boyut: {app.before_image.shape[1]}x{app.before_image.shape[0]} piksel")
    
    with col2:
        st.subheader("üì∏ Sonraki G√∂r√ºnt√º (After)")
        after_file = st.file_uploader(
            "Sonraki g√∂r√ºnt√ºy√º y√ºkleyin",
            type=['png', 'jpg', 'jpeg', 'tiff', 'bmp'],
            key="after",
            help="Deƒüi≈üimlerin tespit edileceƒüi g√∂r√ºnt√º"
        )
        
        if after_file:
            app.after_image = np.array(Image.open(after_file))
            st.image(app.after_image, caption="Sonraki G√∂r√ºnt√º", use_container_width=True)
            st.info(f"üìê Boyut: {app.after_image.shape[1]}x{app.after_image.shape[0]} piksel")
    
    # Kontrol butonlarƒ±
    col1, col2, col3 = st.columns([3, 1, 1])
    
    with col1:
        analyze_btn = st.button(
            "üîç Geli≈ümi≈ü Analiz Ba≈ülat",
            type="primary",
            use_container_width=True,
            disabled=(app.before_image is None or app.after_image is None)
        )
    
    with col2:
        clear_btn = st.button("üóëÔ∏è Temizle", use_container_width=True)
    
    with col3:
        help_btn = st.button("‚ùì Yardƒ±m", use_container_width=True)
    
    # Analiz i≈ülemi
    if analyze_btn:
        with st.spinner('üîÑ Geli≈ümi≈ü analiz yapƒ±lƒ±yor...'):
            try:
                # Threshold hesaplama (sensitivity'den)
                threshold = max(10, 50 - (sensitivity * 4))
                
                # Analiz 
                if method == "Statistical":
                    results = app.detect_changes_statistical(app.before_image, app.after_image)
                elif method == "Morphological":
                    results = app.detect_changes_morphological(app.before_image, app.after_image)
                elif method == "Advanced Preprocessing":
                    results = app.detect_changes_advanced_preprocessing(app.before_image, app.after_image)
                elif method == "Hybrid Enhanced":
                    results = app.detect_changes_hybrid(app.before_image, app.after_image)
                else:
                    results = app.detect_changes_statistical(app.before_image, app.after_image)
                
                # B√∂lge analizi
                if results['change_mask'] is not None:
                    regions = app.analyze_change_regions(results['change_mask'])
                    results['regions'] = regions
                
                # Overlay olu≈üturma
                if results['change_mask'] is not None:
                    overlay = app.create_overlay_visualization(
                        app.before_image, app.after_image, results['change_mask']
                    )
                    results['overlay'] = overlay
                
                st.session_state.results = results
                st.success("‚úÖ Analiz ba≈üarƒ±yla tamamlandƒ±!")
                
            except Exception as e:
                st.error(f"‚ùå Analiz hatasƒ±: {str(e)}")
                st.info("üí° L√ºtfen farklƒ± bir y√∂ntem deneyin veya g√∂r√ºnt√º formatƒ±nƒ± kontrol edin.")
    
    # Temizleme
    if clear_btn:
        if 'results' in st.session_state:
            del st.session_state.results
        st.rerun()
    
    # Yardƒ±m g√∂ster
    if help_btn:
        st.info("""
        ### üöÄ Hƒ±zlƒ± Kullanƒ±m Rehberi
        1. **G√∂r√ºnt√º Y√ºkleme**: ƒ∞ki farklƒ± zamandan uydu g√∂r√ºnt√ºlerini y√ºkleyin
        2. **Y√∂ntem Se√ßimi**: 
           - **Statistical**: En hƒ±zlƒ± ve g√ºvenilir (√∂nerilen)
           - **Morphological**: Yapƒ±sal deƒüi≈üimler i√ßin
           - **Advanced Preprocessing**: En kaliteli sonu√ß (preprocessor gerekli)
           - **Hybrid Enhanced**: Birle≈üik analiz
        3. **Analiz**: Mavi butona tƒ±klayƒ±n
        4. **Sonu√ßlarƒ± ƒ∞nceleyin**: Maskeler, grafikler ve metrikleri g√∂r√ºn
        5. **ƒ∞ndirin**: PNG veya JSON formatƒ±nda sonu√ßlarƒ± kaydedin
        
        ### ‚ö†Ô∏è Sorun Giderme
        - G√∂r√ºnt√ºler farklƒ± boyutlarda olabilir (otomatik d√ºzeltilir)
        - PNG/JPG formatlarƒ± desteklenir
        - B√ºy√ºk g√∂r√ºnt√ºler otomatik k√º√ß√ºlt√ºl√ºr
        """)
    
    # Sonu√ßlarƒ± g√∂sterme
    if 'results' in st.session_state:
        results = st.session_state.results
        change_pct = results.get('change_percentage', 0)
        
        # Sonu√ß √∂zeti
        if change_pct > 10:
            st.markdown(f"""
            <div class="change-detected">
                <h2>üö® Kritik Deƒüi≈üim Tespit Edildi!</h2>
                <p><strong>{change_pct:.2f}%</strong> oranƒ±nda deƒüi≈üim bulundu.</p>
                <p>Toplam <strong>{results.get('changed_pixels', 0):,}</strong> piksel etkilenmi≈ü.</p>
                <p>Kullanƒ±lan y√∂ntem: <strong>{results.get('method', 'N/A')}</strong></p>
            </div>
            """, unsafe_allow_html=True)
        elif change_pct > 3:
            st.markdown(f"""
            <div class="no-change">
                <h2>‚ö†Ô∏è Orta D√ºzey Deƒüi≈üim</h2>
                <p><strong>{change_pct:.2f}%</strong> oranƒ±nda deƒüi≈üim tespit edildi.</p>
                <p>Bu deƒüi≈üim izlenmesi gereken seviyede.</p>
            </div>
            """, unsafe_allow_html=True)
        else:
            st.markdown(f"""
            <div class="no-change">
                <h2>‚úÖ Minimal Deƒüi≈üim</h2>
                <p>Sadece <strong>{change_pct:.2f}%</strong> oranƒ±nda deƒüi≈üim var.</p>
                <p>Normal varyasyon aralƒ±ƒüƒ±nda.</p>
            </div>
            """, unsafe_allow_html=True)
        
        # √ñn i≈üleme bilgileri 
        if 'preprocessing_info' in results and results['preprocessing_info'].get('preprocessing_applied'):
            prep_info = results['preprocessing_info']
            st.markdown("### üî¨ √ñn ƒ∞≈üleme Analizi")
            
            col1, col2, col3 = st.columns(3)
            
            with col1:
                alignment_quality = prep_info.get('alignment_quality', 0)
                delta_alignment = alignment_quality - 0.5 if alignment_quality > 0.5 else None
                st.metric(
                    "üéØ Hizalama Kalitesi",
                    f"{alignment_quality:.3f}",
                    delta=f"{delta_alignment:.3f}" if delta_alignment else None
                )
            
            with col2:
                if 'stats1' in prep_info:
                    contrast_improvement = prep_info['stats1'].get('contrast_improvement', 1.0)
                    delta_contrast = contrast_improvement - 1.0 if contrast_improvement > 1.0 else None
                    st.metric(
                        "üìà Kontrast ƒ∞yile≈ütirme",
                        f"{contrast_improvement:.2f}x",
                        delta=f"{delta_contrast:.2f}x" if delta_contrast else None
                    )
            
            with col3:
                processing_success = "‚úÖ Ba≈üarƒ±lƒ±" if prep_info.get('success', False) else "‚ùå Ba≈üarƒ±sƒ±z"
                st.metric("üîß √ñn ƒ∞≈üleme Durumu", processing_success)
        
        # G√∂rselle≈ütirmeler
        st.subheader("üìä Analiz Sonu√ßlarƒ±")
        
        # Ana g√∂rselle≈ütirmeler
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.markdown("#### üîç Deƒüi≈üim Maskesi")
            st.image(results['change_mask'], caption="Beyaz = Deƒüi≈üim Alanlarƒ±", use_container_width=True)
        
        with col2:
            st.markdown("#### üå°Ô∏è Fark Haritasƒ±")
            st.image(results['difference_map'], caption="Yoƒüunluk = Fark B√ºy√ºkl√ºƒü√º", use_container_width=True)
        
        with col3:
            st.markdown("#### üéØ Overlay G√∂r√ºnt√º")
            st.image(results['overlay'], caption="Kƒ±rmƒ±zƒ± = Tespit Edilen Deƒüi≈üimler", use_container_width=True)
        
        # ƒ∞nteraktif dashboard
        st.subheader("üìà ƒ∞nteraktif Analiz Dashboard")
        
        # Dashboard container ile wrap ettim
        with st.container():
            st.markdown('<div class="plotly-container">', unsafe_allow_html=True)
            
            try:
                # Dashboard olu≈üturma
                fig = make_subplots(
                    rows=2, cols=2,
                    subplot_titles=(
                        'Confidence Daƒüƒ±lƒ±mƒ±', 
                        'Deƒüi≈üim B√∂lgeleri',
                        'Piksel Deƒüer Kar≈üƒ±la≈ütƒ±rma',
                        'Ana Metrikler'
                    ),
                    specs=[
                        [{"type": "histogram"}, {"type": "scatter"}],
                        [{"type": "histogram"}, {"type": "bar"}]
                    ],
                    vertical_spacing=0.12,  # Alt-√ºst arasƒ± bo≈üluk
                    horizontal_spacing=0.1   # Yan-yana arasƒ± bo≈üluk
                )
                
                # Confidence histogram
                confidence_flat = results['confidence_map'].flatten()
                fig.add_histogram(x=confidence_flat, name="G√ºven Skoru", row=1, col=1, nbinsx=50)
                
                # B√∂lge scatter plot
                if 'regions' in results and results['regions']:
                    regions = results['regions']
                    fig.add_scatter(
                        x=[r['centroid'][0] for r in regions],
                        y=[r['centroid'][1] for r in regions],
                        mode='markers',
                        marker=dict(
                            size=[min(30, np.sqrt(r['area']/10)) for r in regions],  # Boyut k√º√ß√ºlt√ºld√º
                            color=[r['area'] for r in regions],
                            colorscale='Reds',
                            showscale=True,
                            colorbar=dict(title="Alan (piksel)", x=0.48)  # Colorbar pozisyonu
                        ),
                        name="Deƒüi≈üim B√∂lgeleri",
                        text=[f"B√∂lge {i+1}: {r['area']} px" for i, r in enumerate(regions)],
                        row=1, col=2
                    )
                
                # Piksel deƒüer kar≈üƒ±la≈ütƒ±rma - sampling ile hƒ±zlandƒ±rma
                before_gray = cv2.cvtColor(app.before_image, cv2.COLOR_RGB2GRAY)
                after_gray = cv2.cvtColor(app.after_image, cv2.COLOR_RGB2GRAY)
                
                # Daha az sample almak
                sample_size = min(10000, before_gray.size)
                indices = np.random.choice(before_gray.size, sample_size, replace=False)
                
                fig.add_histogram(x=before_gray.flatten()[indices], name="√ñnceki", 
                                opacity=0.7, row=2, col=1, nbinsx=30)
                fig.add_histogram(x=after_gray.flatten()[indices], name="Sonraki", 
                                opacity=0.7, row=2, col=1, nbinsx=30)
                
                # Metrik barlarƒ±
                metrics = ['Deƒüi≈üim %', 'B√∂lge Sayƒ±sƒ±', 'Ortalama G√ºven']
                values = [
                    change_pct,
                    len(results.get('regions', [])),
                    np.mean(confidence_flat) * 100
                ]
                
                colors = ['#e74c3c', '#3498db', '#f39c12']
                fig.add_bar(x=metrics, y=values, name="Ana Metrikler", 
                           row=2, col=2, marker_color=colors)
                
                # Layout g√ºncellemeleri
                fig.update_layout(
                    height=500,  # Y√ºkseklik k√º√ß√ºlt√ºld√º
                    showlegend=False,  # Legend kapatƒ±ldƒ± (yer kazanmak i√ßin)
                    title_text="Kapsamlƒ± Analiz Dashboard",
                    title_x=0.5,
                    title_font_size=16,
                    margin=dict(l=50, r=50, t=80, b=50)  # Margin'ler ayarlandƒ±
                )
                
                # Subplot ba≈ülƒ±klarƒ±nƒ± k√º√ß√ºltme
                for annotation in fig['layout']['annotations']:
                    annotation['font'] = dict(size=12)
                
                st.plotly_chart(fig, use_container_width=True, key="dashboard_chart")
                
            except Exception as e:
                st.warning(f"Dashboard olu≈üturma hatasƒ± (g√∂rselle≈ütirme atlandƒ±): {e}")
                
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("Deƒüi≈üim Oranƒ±", f"{change_pct:.1f}%")
                with col2:
                    st.metric("B√∂lge Sayƒ±sƒ±", len(results.get('regions', [])))
                with col3:
                    st.metric("Ortalama G√ºven", f"{np.mean(confidence_flat):.3f}")
            
            st.markdown('</div>', unsafe_allow_html=True)
        
        # B√∂lge detay analizi
        if 'regions' in results and results['regions']:
            st.subheader("üìç Tespit Edilen Deƒüi≈üim B√∂lgeleri")
            
            # Tablo verisi olu≈üturma
            table_data = []
            for i, region in enumerate(results['regions'][:10]):
                table_data.append({
                    'B√∂lge ID': f"R{i+1}",
                    'Alan (piksel)': f"{region['area']:,}",
                    'Alan (%)': f"{(region['area']/results['total_pixels']*100):.3f}%",
                    'Merkez X': f"{region['centroid'][0]:.1f}",
                    'Merkez Y': f"{region['centroid'][1]:.1f}",
                    'Geni≈ülik': region['bbox'][2],
                    'Y√ºkseklik': region['bbox'][3]
                })
            
            df = pd.DataFrame(table_data)
            st.dataframe(df, use_container_width=True)
        
        # ƒ∞ndirme se√ßenekleri
        st.subheader("üíæ Sonu√ßlarƒ± ƒ∞ndir")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            # Deƒüi≈üim maskesi
            try:
                mask_bytes = cv2.imencode('.png', results['change_mask'])[1].tobytes()
                st.download_button(
                    "üñºÔ∏è Deƒüi≈üim Maskesi",
                    mask_bytes,
                    file_name=f"change_mask_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png",
                    mime="image/png",
                    use_container_width=True
                )
            except Exception as e:
                st.error(f"Mask indirme hatasƒ±: {e}")
        
        with col2:
            # Overlay g√∂r√ºnt√º
            try:
                overlay_rgb = cv2.cvtColor(results['overlay'], cv2.COLOR_RGB2BGR)
                overlay_bytes = cv2.imencode('.png', overlay_rgb)[1].tobytes()
                st.download_button(
                    "üéØ Overlay G√∂r√ºnt√º",
                    overlay_bytes,
                    file_name=f"overlay_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png",
                    mime="image/png",
                    use_container_width=True
                )
            except Exception as e:
                st.error(f"Overlay indirme hatasƒ±: {e}")
        
        with col3:
            # G√ºven haritasƒ±
            try:
                confidence_img = (results['confidence_map'] * 255).astype(np.uint8)
                conf_bytes = cv2.imencode('.png', confidence_img)[1].tobytes()
                st.download_button(
                    "üå°Ô∏è G√ºven Haritasƒ±",
                    conf_bytes,
                    file_name=f"confidence_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png",
                    mime="image/png",
                    use_container_width=True
                )
            except Exception as e:
                st.error(f"Confidence indirme hatasƒ±: {e}")
        
        with col4:
            # JSON rapor
            try:
                report_data = {
                    'analiz_zamani': datetime.now().isoformat(),
                    'yontem': results.get('method', 'N/A'),
                    'degisim_yuzdesi': float(change_pct),
                    'degisen_piksel': int(results.get('changed_pixels', 0)),
                    'toplam_piksel': int(results.get('total_pixels', 0)),
                    'bolge_sayisi': len(results.get('regions', [])),
                    'en_buyuk_5_bolge': results.get('regions', [])[:5],
                    'parametreler': {
                        'duyarlilik': int(sensitivity),
                        'min_bolge_boyutu': int(min_region_size),
                        'morfolojik_temizleme': bool(morphological_ops)
                    },
                    'sistem_durumu': {
                        'gelismis_preprocessor': bool(PREPROCESSOR_AVAILABLE),
                        'utils_modul': bool(UTILS_AVAILABLE),
                        'visualizer_modul': bool(VISUALIZER_AVAILABLE)
                    }
                }
                
                # √ñn i≈üleme bilgilerini ekleme
                if 'preprocessing_info' in results:
                    report_data['on_isleme'] = convert_numpy_types(results['preprocessing_info'])
                
                # JSON'u g√ºvenli ≈üekilde serialize etmek
                json_str = json.dumps(report_data, indent=2, ensure_ascii=False, default=str)
                
                st.download_button(
                    "üìä JSON Rapor",
                    json_str,
                    file_name=f"change_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                    mime="application/json",
                    use_container_width=True
                )
            except Exception as e:
                st.error(f"JSON indirme hatasƒ±: {e}")

if __name__ == "__main__":
    main()